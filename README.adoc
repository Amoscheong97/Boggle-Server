## Introduction
I have created a server called Boggle Server that handles HTTP requests for clients who want to play the game.
In this README, I will be briefly summarize on what the server does and what are the actions it takes when it receives
a specific HTTP request. For deeper understanding of the Boggle Server, please refer to the code as there are comments to explain the mechanisms of the different lines of code.

## Prerequisite
* The request sent to the Boggle Server must be of json content, else the server will reject the request.
* There should be two internal test_board.txt and dictionary.txt files already existing within the server.

## Set up the Server

To set up the server, input the following at the command line:
```
py BoggleServer.py
```

After that, you should see the output :
```
Starting httpd on port 9000...
```

From here on, the server will wait for HTTP requests.

## How the server works
There are 3 HTTP requests that the game handles: POST, PUT, GET. There are three methods to handle the requests: `do_POST(self)`, `do_GET(self)`, `do_PUT(self)`

The following code is shared by all three requests, where it will reject any non-JSON content: 

```
ctype, pdict = cgi.parse_header(self.headers.get('content-type'))

        # refuse to receive non-json content
        if ctype != 'application/json':
            send_boggle_response(self, 400, {'message': "Content should be of JSON object"})    
            return
```

The variable ctype is used to check for the data type of the content received and it wil send an error response of JSON object with message: "Content should be of JSON object". Whenever the server wants to sends a response to the client it will call a `send_boggle_response` method. In the case of the above example, the server invoked a method: 
`send_boggle_response(self, 400, {'message': "Content should be of JSON object"})` . This means the server is sending an error code of 404 and it is sending a JSON object `{'message': "Content should be of JSON object"}`, where it contains a message for the client and in this case, telling them that the object received by the server is not a JSON object.

### POST request
POST request is sent when the client wants to play a new game of Boggle.
The JSON object sent to the server will be converted to a python dictionary. The server will check if the keys `random` and `duration` exists in the python dictionary. 

This is the conditional statement in the code that checks if the keys exist in the dictionary:
```
if keyExist(message, 'duration') and keyExist(message, 'random')
```

If either one is missing, the server will send a response code of 400 (Error) and json object with a key `message` where it contains the message: `Invalid Input`.

* Example: `127.0.0.1 - - [03/Mar/2020 20:02:14] "POST /games HTTP/1.1" 400 -`
The number `400` represents the response code given by the user

If the key 'random' is true, the server will generate a random board using the method `generateNewBoard()` , else the server will add a new key called `board` to the python dictionary. It is optional for the client to add in the `board` key, if there is no such key, the server will take the board from the text file: 

```
if not keyExist(message, 'board'):
    with open('test_board.txt', 'r') as testboard:
        message['board'] = testboard.readline().replace('\n', '')
```

Then, the server will add two more keys, `id` and `token`. There is a global variable that is incremented for every game created. For example, if the server just started, the global variable has a value of 1. The value 1 will be assigned to the first game created, then that global variable is incremented to 2, which means the next game will have a game ID of 2. 

```
message['id'] = gameID
message['token'] = secrets.token_hex(16)
```
As shown in the example above, the `token` will be auto generated by the server with the line `secrets.token_hex(16)` where it will generate a random 32 letter ASCII string . The new value that is auto-generated is the new token for that particular game. After adding these keys, the python dictionary is converted back to JSON and sent back to the client with a response code of 201.

* Example: `127.0.0.1 - - [03/Mar/2020 20:02:10] "POST /games HTTP/1.1" 201 -`

### PUT request
The PUT request happens when the client start to play the game by putting in a new word. The `do_PUT(self)` method is invoked when a PUT request is called. 

Just like the POST request, the JSON object received by the user will be converted to a python dictionary. This time round, the server has to handle the game which the client wants to access. If the client wants to access the game with gameID 2, the path will be `/games/2`. The server will get the ID from the path and get the POSTed data previously added by client. 

```
getID = requestID(self.path)
keyID = str(getID)
```

The variable getID contains a method `requestID(self.path)` where it takes in the path of the request and returns an integer value which is the game ID. The variable keyID is a string format of the ID and it is used to access the value of the dictionary data.

```
data = SAVED[keyID]

# Get time left for the particular game
timing = time.time() - timekeeper[keyID]
```
The global variable SAVED is a list that stores all dictionary values of the games.
The global variable timekeeper is a list that keep tracks of the time for each game using the keyID variable.

The ID will also be validated in case it is an invalid ID. The amount of time left for the client is keep track as well. If the time spent by the client to play the game has exceeded the duration of the game, it will raise an error and sends a JSON object, telling the client that the game has ended.

The returned JSON object is as such : 
```
{
'message' : "Times Up! Game is no longer available",
'points_earned': *POINTS EARNED BY CLIENT*
}
```
In addition, the token that is passed in by the client is also use to validate if the user has the rights to access that particular game.

Snippet of the validation code (Takes the token value from the saved data and compare to the token given by client):
```
elif gamerequest['token'] != data['token']:
```

Assuming now there are no errors received from the client, the server will proceed to check the dictionary and compare it to the word given by the client. It will also check if the word can be formed on the board. The server uses two methods, `isValidWord` and `isCorrectWord` for validation. Both methods will return a boolean value and when we perform the and operator on these two values, we will get what we want. When both of these conditions are met, the client will accumulate points for that particular game. The accumulated points is based on the length of the word. For example, `tap` is worth 3 points and `final` is worth 5 points.

The POSTed data, given by the client, will be returned to the client, with a few adjustments. There will be a new key `time_left` added to the JSON object, letting the client know the time left before the game expires. 

A successful PUT request is as such: 
`127.0.0.1 - - [03/Mar/2020 19:59:54] "PUT /games/4 HTTP/1.1" 200 -`

### GET request
In order to get the game information, a GET request is called.

The validation mechanism for PUT request and GET request are both the same. Both check if the ID given by the client is valid and if the game is already expired. The only thing different is that, once it retrieves the POSTed data, it edits the `time_left` key of the python dictionary. Then it simply converts the dictionary to JSON object and returns to the client.

A successful GET request is as such: 
`127.0.0.1 - - [03/Mar/2020 20:00:17] "GET /games/7 HTTP/1.1" 200 -`
